move (8-bit)
	0 0 S S S D D D
	[A, B, C, D, M1, M2, X, Y] -> [A, B, C, D, X, Y, M1, M2]
	[PC] += 1
	S S S Source register	|	D D D Destination register
		0 0 0 	A			|	0 0 0	A
		0 0 1 	B			|	0 0 1	B
		0 1 0 	C			|	0 1 0	C
		0 1 1 	D			|	0 1 1	D
		1 0 0	M1			|	1 0 0	X
		1 0 1	M2			|	1 0 1	Y
		1 1 0	X			|	1 1 0	M1
		1 1 1	Y			|	1 1 1	M2


load from memory (8-bit)
	1 0 1 0 1 D D D
	[mem(M)] -> [A, B, C, D, X, Y, J1, J2]
	[PC] += 1
		D D D Destination register
		0 0 0	A
		0 0 1	B
		0 1 0	C
		0 1 1	D
		1 0 0	X
		1 0 1	Y
		1 1 0	J1
		1 1 1	J2	

load immediate (8-bin)
	X X X X X D D D    V V V V V V V V
	[next val] -> [A, B, C, D, M1, M2, X, Y]
	[PC] += 2 

load immediate (16-bit)
	X X X X X X D D    V V V V V V V V    V V V V V V V V
	[next val] -> [M, XY, J]
	[PC] += 3 

move (16-bit)
	X X X X S S S D
	[M, XY, J, INC, PC] -> [XY, PC]
	[PC] += 1
	
alu	- ADD, INC, AND, OR, XOR, NOT, SHL, NOP
	X X O O O D D D
	[A, B] -> [C, D, M1, M2, X, Y, J1, J2]
	[PC] += 1
	

	
store to memory
	X X X X X S S S 
	[A, B, C, D, X, Y, J1, J2] -> [mem(M)]
	[PC] += 1
	
return
	X X X X X X X X
	[XY] -> PC
	[PC] += 1
	
jump if flag
	X X X X N Z O F
	flags
		zero
		overflow
		sign
	if flag
		[PC] -> [XY] 
		[J] -> [PC]
	[PC] += 1
	
	
alocation	

0 0 S S S D D D		move (8-bit)
0 1 O O O D D D		alu
1 0 0 0 S S S D		move (16-bit)
1 0 0 1 N Z O F		jump if flag
1 0 1 0 0 D D D		load immediate (8-bin)
1 0 1 0 1 D D D		load from memory (8-bit)
1 0 1 1 0 S S S		store to memory
1 0 1 1 1 0 D D    	load immediate (16-bit)
1 0 1 1 1 1 0 0		return
